Source code of vuln.c indicates that program does a lot of fancy operations just to drag our attention away from lines that can be exploited. This challenge is a classic example of Format String Attack that some of C functions are vulnerable to.

![Screenshot 2022-05-21 205356](https://user-images.githubusercontent.com/77243003/169665493-1aab9163-8b63-40bd-bcb7-d274a4bdd22b.png)

Here we can see that right after we provide our input to be stored in variable 'user_buf', that variable is being passed as a first argument to printf() function executing right after. That means we can trick printf() to print memory addresses from the stack, following the format we provided. In flag.sh, I decided to make it a little more convenient by calling python to print '%x' * 200 and pipe it directly to the server. We can't forget that '1\n' has to be also included since vuln.c asks whether we want to buy stonks beforehand. Everything is then piped to stream editor (sed) that makes sure we only get the line printed by printf() we modified and discard unnecesary data. That's what we are presented with:

![Screenshot 2022-05-21 211627](https://user-images.githubusercontent.com/77243003/169666185-1c2edad4-b276-4f8d-9f68-909819319610.png)

Everything is assigned to $hexdump variable and exported so that it can be loaded to python using os.environ["hexdump"]. Next step is converting these bytes to characters. I have used try/except blocked for that since some characters cannot be converted using Ascii decoding - we are not interested in those characters anyway so we can let them stay in hexadecimal form. That's what we get: 

![Screenshot 2022-05-21 212625](https://user-images.githubusercontent.com/77243003/169666426-6097039a-0c8a-4e5b-bfbc-a1b62d0bbc30.png)

If we look closely we can notice the flag pattern.

![Screenshot 2022-05-21 212625](https://user-images.githubusercontent.com/77243003/169666495-2ec9a657-e555-41d7-a76d-67f705867daa.png)

The reason order of letters is different from expected, is the fact that those values are taken straight from memory addresses where they reside in order set by little endian notation with least significant bytes before more sigificant bytes (that behavior is something to keep in mind when working with memory addresses of processors using x86 Instruction Set Architecture - basically any modern desktop/laptop CPU except Apple's M1). Firstly, we need to get rid of all the bytes that we are not interested in. For that we are filtering that python list starting with index of character "o". We have to do it that way since that index can be changing, most likely depending on what's currently stored in memory. Then we have to join items together again in nested lists, 4 byte (32-bit or double word) each in reverse order. Those 4 character strings we are gonna finally join together as well to form our flag. That's the final result:

![Screenshot 2022-05-21 215030](https://user-images.githubusercontent.com/77243003/169667021-d1bfc92e-1dbd-4ac3-a032-4ca3f7a1c9f5.png)

Sources I used:
https://owasp.org/www-community/attacks/Format_string_attack
